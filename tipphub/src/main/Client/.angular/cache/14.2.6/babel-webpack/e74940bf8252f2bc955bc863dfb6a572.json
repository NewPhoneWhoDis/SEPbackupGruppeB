{"ast":null,"code":"import { DataSource } from '@angular/cdk/collections';\nimport { map } from 'rxjs/operators';\nimport { of as observableOf, merge } from 'rxjs'; // TODO: replace this with real data from your application\n\nconst EXAMPLE_DATA = [{\n  id: 1,\n  name: 'Hydrogen'\n}, {\n  id: 2,\n  name: 'Helium'\n}, {\n  id: 3,\n  name: 'Lithium'\n}, {\n  id: 4,\n  name: 'Beryllium'\n}, {\n  id: 5,\n  name: 'Boron'\n}, {\n  id: 6,\n  name: 'Carbon'\n}, {\n  id: 7,\n  name: 'Nitrogen'\n}, {\n  id: 8,\n  name: 'Oxygen'\n}, {\n  id: 9,\n  name: 'Fluorine'\n}, {\n  id: 10,\n  name: 'Neon'\n}, {\n  id: 11,\n  name: 'Sodium'\n}, {\n  id: 12,\n  name: 'Magnesium'\n}, {\n  id: 13,\n  name: 'Aluminum'\n}, {\n  id: 14,\n  name: 'Silicon'\n}, {\n  id: 15,\n  name: 'Phosphorus'\n}, {\n  id: 16,\n  name: 'Sulfur'\n}, {\n  id: 17,\n  name: 'Chlorine'\n}, {\n  id: 18,\n  name: 'Argon'\n}, {\n  id: 19,\n  name: 'Potassium'\n}, {\n  id: 20,\n  name: 'Calcium'\n}];\n/**\n * Data source for the LeagueTable view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\n\nexport class LeagueTableDataSource extends DataSource {\n  constructor() {\n    super();\n    this.data = EXAMPLE_DATA;\n  }\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n\n\n  connect() {\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange).pipe(map(() => {\n        return this.getPagedData(this.getSortedData([...this.data]));\n      }));\n    } else {\n      throw Error('Please set the paginator and sort on the data source before connecting.');\n    }\n  }\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n\n\n  disconnect() {}\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n\n\n  getPagedData(data) {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n\n\n  getSortedData(data) {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      const isAsc = this.sort?.direction === 'asc';\n\n      switch (this.sort?.active) {\n        case 'name':\n          return compare(a.name, b.name, isAsc);\n\n        case 'id':\n          return compare(+a.id, +b.id, isAsc);\n\n        default:\n          return 0;\n      }\n    });\n  }\n\n}\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n\nfunction compare(a, b, isAsc) {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}","map":null,"metadata":{},"sourceType":"module"}